{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"normalizeLocalePath\", {\n  enumerable: true,\n  get: function () {\n    return normalizeLocalePath;\n  }\n});\n\nfunction normalizeLocalePath(pathname, locales) {\n  let detectedLocale; // first item will be empty string from splitting at first char\n\n  const pathnameParts = pathname.split('/');\n  (locales || []).some(locale => {\n    if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {\n      detectedLocale = locale;\n      pathnameParts.splice(1, 1);\n      pathname = pathnameParts.join('/') || '/';\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    pathname,\n    detectedLocale\n  };\n}","map":{"version":3,"mappings":";;;;;+BAcgBA;kBAAAA;;WAAAA;;AAAAA;;AAAT,SAASA,mBAAT,CACLC,QADK,EAELC,OAFK,EAEa;EAElB,IAAIC,cAAJ,CAFkB,CAGlB;;EACA,MAAMC,gBAAgBH,SAASI,KAATJ,CAAe,GAAfA,CAAtB;EAEEC,YAAW,EAAXA,EAAeI,IAAfJ,CAAqBK,MAAD,IAACA;IACrB,IACEH,aAAa,CAAC,CAAD,CAAbA,IACAA,aAAa,CAAC,CAAD,CAAbA,CAAiBI,WAAjBJ,OAAmCG,OAAOC,WAAPD,EAFrC,EAGE;MACAJ,iBAAiBI,MAAjBJ;MACAC,cAAcK,MAAdL,CAAqB,CAArBA,EAAwB,CAAxBA;MACAH,WAAWG,cAAcM,IAAdN,CAAmB,GAAnBA,KAA2B,GAAtCH;MACA,OAAO,IAAP;IACF;;IACA,OAAO,KAAP;EACF,CAXEC;EAaF,OAAO;IACLD,QADK;IAELE;EAFK,CAAP;AAIF","names":["normalizeLocalePath","pathname","locales","detectedLocale","pathnameParts","split","some","locale","toLowerCase","splice","join"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\shared\\lib\\i18n\\normalize-locale-path.ts"],"sourcesContent":["export interface PathLocale {\n  detectedLocale?: string\n  pathname: string\n}\n\n/**\n * For a pathname that may include a locale from a list of locales, it\n * removes the locale from the pathname returning it alongside with the\n * detected locale.\n *\n * @param pathname A pathname that may include a locale.\n * @param locales A list of locales.\n * @returns The detected locale and pathname without locale\n */\nexport function normalizeLocalePath(\n  pathname: string,\n  locales?: string[]\n): PathLocale {\n  let detectedLocale: string | undefined\n  // first item will be empty string from splitting at first char\n  const pathnameParts = pathname.split('/')\n\n  ;(locales || []).some((locale) => {\n    if (\n      pathnameParts[1] &&\n      pathnameParts[1].toLowerCase() === locale.toLowerCase()\n    ) {\n      detectedLocale = locale\n      pathnameParts.splice(1, 1)\n      pathname = pathnameParts.join('/') || '/'\n      return true\n    }\n    return false\n  })\n\n  return {\n    pathname,\n    detectedLocale,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}