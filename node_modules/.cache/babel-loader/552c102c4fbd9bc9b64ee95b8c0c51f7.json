{"ast":null,"code":"/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"parsePath\", {\n  enumerable: true,\n  get: function () {\n    return parsePath;\n  }\n});\n\nfunction parsePath(path) {\n  const hashIndex = path.indexOf('#');\n  const queryIndex = path.indexOf('?');\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : ''\n    };\n  }\n\n  return {\n    pathname: path,\n    query: '',\n    hash: ''\n  };\n}","map":{"version":3,"mappings":"AAAA;;;;;AAIC;;;;;+BACeA;kBAAAA;;WAAAA;;AAAAA;;AAAT,SAASA,SAAT,CAAmBC,IAAnB,EAA+B;EACpC,MAAMC,YAAYD,KAAKE,OAALF,CAAa,GAAbA,CAAlB;EACA,MAAMG,aAAaH,KAAKE,OAALF,CAAa,GAAbA,CAAnB;EACA,MAAMI,WAAWD,aAAa,CAAC,CAAdA,KAAoBF,YAAY,CAAZA,IAAiBE,aAAaF,SAAlDE,CAAjB;;EAEA,IAAIC,YAAYH,YAAY,CAAC,CAA7B,EAAgC;IAC9B,OAAO;MACLI,UAAUL,KAAKM,SAALN,CAAe,CAAfA,EAAkBI,WAAWD,UAAXC,GAAwBH,SAA1CD,CADL;MAELO,OAAOH,WACHJ,KAAKM,SAALN,CAAeG,UAAfH,EAA2BC,YAAY,CAAC,CAAbA,GAAiBA,SAAjBA,GAA6BO,SAAxDR,CADGI,GAEH,EAJC;MAKLK,MAAMR,YAAY,CAAC,CAAbA,GAAiBD,KAAKU,KAALV,CAAWC,SAAXD,CAAjBC,GAAyC;IAL1C,CAAP;EAOF;;EAEA,OAAO;IAAEI,UAAUL,IAAZ;IAAkBO,OAAO,EAAzB;IAA6BE,MAAM;EAAnC,CAAP;AACF","names":["parsePath","path","hashIndex","indexOf","queryIndex","hasQuery","pathname","substring","query","undefined","hash","slice"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\shared\\lib\\router\\utils\\parse-path.ts"],"sourcesContent":["/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n"]},"metadata":{},"sourceType":"script"}