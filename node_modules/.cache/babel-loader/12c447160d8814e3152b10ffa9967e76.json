{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getNamedMiddlewareRegex: null,\n  getNamedRouteRegex: null,\n  getRouteRegex: null,\n  parseParameter: null\n});\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  getNamedMiddlewareRegex: function () {\n    return getNamedMiddlewareRegex;\n  },\n  getNamedRouteRegex: function () {\n    return getNamedRouteRegex;\n  },\n  getRouteRegex: function () {\n    return getRouteRegex;\n  },\n  parseParameter: function () {\n    return parseParameter;\n  }\n});\n\nconst _constants = require(\"../../../../lib/constants\");\n\nconst _interceptionroutes = require(\"../../../../server/lib/interception-routes\");\n\nconst _escaperegexp = require(\"../../escape-regexp\");\n\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\n/**\n * Regular expression pattern used to match route parameters.\n * Matches both single parameters and parameter groups.\n * Examples:\n *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n */\n\n\nconst PARAMETER_PATTERN = /\\[((?:\\[.*\\])|.+)\\]/;\n\nfunction parseParameter(param) {\n  const match = param.match(PARAMETER_PATTERN);\n\n  if (!match) {\n    return parseMatchedParameter(param);\n  }\n\n  return parseMatchedParameter(match[1]);\n}\n/**\n * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n * @param param - The matched parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\n\n\nfunction parseMatchedParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  const repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\n\nfunction getParametrizedRoute(route) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(segment => {\n      const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n\n      const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n      ;\n\n      if (markerMatch && paramMatches) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseMatchedParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n      } else if (paramMatches) {\n        const {\n          key,\n          repeat,\n          optional\n        } = parseMatchedParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(''),\n    groups\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  const {\n    parameterizedRoute,\n    groups\n  } = getParametrizedRoute(normalizedRoute);\n  return {\n    re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\n\n\nfunction buildGetSafeRouteKey() {\n  let i = 0;\n  return () => {\n    let routeKey = '';\n    let j = ++i;\n\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + (j - 1) % 26);\n      j = Math.floor((j - 1) / 26);\n    }\n\n    return routeKey;\n  };\n}\n\nfunction getSafeKeyFromSegment(param) {\n  let {\n    interceptionMarker,\n    getSafeRouteKey,\n    segment,\n    routeKeys,\n    keyPrefix\n  } = param;\n  const {\n    key,\n    optional,\n    repeat\n  } = parseMatchedParameter(segment); // replace any non-word characters since they can break\n  // the named regex\n\n  let cleanedKey = key.replace(/\\W/g, '');\n\n  if (keyPrefix) {\n    cleanedKey = \"\" + keyPrefix + cleanedKey;\n  }\n\n  let invalidKey = false; // check if the key is still invalid and fallback to using a known\n  // safe key\n\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true;\n  }\n\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true;\n  }\n\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey();\n  }\n\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n  } else {\n    routeKeys[cleanedKey] = key;\n  } // if the segment has an interception marker, make sure that's part of the regex pattern\n  // this is to ensure that the route with the interception marker doesn't incorrectly match\n  // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n\n\n  const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : '';\n  return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\n\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split('/');\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(segment => {\n      const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(m => segment.startsWith(m));\n\n      const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n      ;\n\n      if (hasInterceptionMarker && paramMatches) {\n        const [usedMarker] = segment.split(paramMatches[0]);\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          interceptionMarker: usedMarker,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n        });\n      } else if (paramMatches) {\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : undefined\n        });\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(''),\n    routeKeys\n  };\n}\n\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n  const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n  return { ...getRouteRegex(normalizedRoute),\n    namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n    routeKeys: result.routeKeys\n  };\n}\n\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  const {\n    parameterizedRoute\n  } = getParametrizedRoute(normalizedRoute);\n  const {\n    catchAll = true\n  } = options;\n\n  if (parameterizedRoute === '/') {\n    let catchAllRegex = catchAll ? '.*' : '';\n    return {\n      namedRegex: \"^/\" + catchAllRegex + \"$\"\n    };\n  }\n\n  const {\n    namedParameterizedRoute\n  } = getNamedParametrizedRoute(normalizedRoute, false);\n  let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : '';\n  return {\n    namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n  };\n}","map":{"version":3,"mappings":"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","names":["getNamedMiddlewareRegex","getNamedRouteRegex","getRouteRegex","parseParameter","PARAMETER_PATTERN","param","match","parseMatchedParameter","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","removeTrailingSlash","split","groups","groupIndex","parameterizedRoute","map","segment","markerMatch","INTERCEPTION_ROUTE_MARKERS","find","m","paramMatches","pos","escapeStringRegexp","join","normalizedRoute","re","RegExp","buildGetSafeRouteKey","i","routeKey","j","String","fromCharCode","Math","floor","getSafeKeyFromSegment","interceptionMarker","getSafeRouteKey","routeKeys","keyPrefix","cleanedKey","replace","invalidKey","length","isNaN","parseInt","interceptionPrefix","getNamedParametrizedRoute","prefixRouteKeys","namedParameterizedRoute","hasInterceptionMarker","some","usedMarker","NEXT_INTERCEPTION_MARKER_PREFIX","undefined","NEXT_QUERY_PARAM_PREFIX","prefixRouteKey","result","namedRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\shared\\lib\\router\\utils\\route-regex.ts"],"sourcesContent":["import {\n  NEXT_INTERCEPTION_MARKER_PREFIX,\n  NEXT_QUERY_PARAM_PREFIX,\n} from '../../../../lib/constants'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../../server/lib/interception-routes'\nimport { escapeStringRegexp } from '../../escape-regexp'\nimport { removeTrailingSlash } from './remove-trailing-slash'\n\nexport interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\nexport interface RouteRegex {\n  groups: { [groupName: string]: Group }\n  re: RegExp\n}\n\n/**\n * Regular expression pattern used to match route parameters.\n * Matches both single parameters and parameter groups.\n * Examples:\n *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n */\nconst PARAMETER_PATTERN = /\\[((?:\\[.*\\])|.+)\\]/\n\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[[...slug]]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[[foo]]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `[bar]` -> `{ key: 'bar', repeat: false, optional: false }`\n *   - `fizz` -> `{ key: 'fizz', repeat: false, optional: false }`\n * @param param - The parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nexport function parseParameter(param: string) {\n  const match = param.match(PARAMETER_PATTERN)\n\n  if (!match) {\n    return parseMatchedParameter(param)\n  }\n\n  return parseMatchedParameter(match[1])\n}\n\n/**\n * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n * @param param - The matched parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nfunction parseMatchedParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nfunction getParametrizedRoute(route: string) {\n  const segments = removeTrailingSlash(route).slice(1).split('/')\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  return {\n    parameterizedRoute: segments\n      .map((segment) => {\n        const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =>\n          segment.startsWith(m)\n        )\n        const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n\n        if (markerMatch && paramMatches) {\n          const { key, optional, repeat } = parseMatchedParameter(\n            paramMatches[1]\n          )\n          groups[key] = { pos: groupIndex++, repeat, optional }\n          return `/${escapeStringRegexp(markerMatch)}([^/]+?)`\n        } else if (paramMatches) {\n          const { key, repeat, optional } = parseMatchedParameter(\n            paramMatches[1]\n          )\n          groups[key] = { pos: groupIndex++, repeat, optional }\n          return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n        } else {\n          return `/${escapeStringRegexp(segment)}`\n        }\n      })\n      .join(''),\n    groups,\n  }\n}\n\n/**\n * From a normalized route this function generates a regular expression and\n * a corresponding groups object intended to be used to store matching groups\n * from the regular expression.\n */\nexport function getRouteRegex(normalizedRoute: string): RouteRegex {\n  const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute)\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups: groups,\n  }\n}\n\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let i = 0\n\n  return () => {\n    let routeKey = ''\n    let j = ++i\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + ((j - 1) % 26))\n      j = Math.floor((j - 1) / 26)\n    }\n    return routeKey\n  }\n}\n\nfunction getSafeKeyFromSegment({\n  interceptionMarker,\n  getSafeRouteKey,\n  segment,\n  routeKeys,\n  keyPrefix,\n}: {\n  interceptionMarker?: string\n  getSafeRouteKey: () => string\n  segment: string\n  routeKeys: Record<string, string>\n  keyPrefix?: string\n}) {\n  const { key, optional, repeat } = parseMatchedParameter(segment)\n\n  // replace any non-word characters since they can break\n  // the named regex\n  let cleanedKey = key.replace(/\\W/g, '')\n\n  if (keyPrefix) {\n    cleanedKey = `${keyPrefix}${cleanedKey}`\n  }\n  let invalidKey = false\n\n  // check if the key is still invalid and fallback to using a known\n  // safe key\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true\n  }\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true\n  }\n\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey()\n  }\n\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = `${keyPrefix}${key}`\n  } else {\n    routeKeys[cleanedKey] = key\n  }\n\n  // if the segment has an interception marker, make sure that's part of the regex pattern\n  // this is to ensure that the route with the interception marker doesn't incorrectly match\n  // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n  const interceptionPrefix = interceptionMarker\n    ? escapeStringRegexp(interceptionMarker)\n    : ''\n\n  return repeat\n    ? optional\n      ? `(?:/${interceptionPrefix}(?<${cleanedKey}>.+?))?`\n      : `/${interceptionPrefix}(?<${cleanedKey}>.+?)`\n    : `/${interceptionPrefix}(?<${cleanedKey}>[^/]+?)`\n}\n\nfunction getNamedParametrizedRoute(route: string, prefixRouteKeys: boolean) {\n  const segments = removeTrailingSlash(route).slice(1).split('/')\n  const getSafeRouteKey = buildGetSafeRouteKey()\n  const routeKeys: { [named: string]: string } = {}\n  return {\n    namedParameterizedRoute: segments\n      .map((segment) => {\n        const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =>\n          segment.startsWith(m)\n        )\n        const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n\n        if (hasInterceptionMarker && paramMatches) {\n          const [usedMarker] = segment.split(paramMatches[0])\n\n          return getSafeKeyFromSegment({\n            getSafeRouteKey,\n            interceptionMarker: usedMarker,\n            segment: paramMatches[1],\n            routeKeys,\n            keyPrefix: prefixRouteKeys\n              ? NEXT_INTERCEPTION_MARKER_PREFIX\n              : undefined,\n          })\n        } else if (paramMatches) {\n          return getSafeKeyFromSegment({\n            getSafeRouteKey,\n            segment: paramMatches[1],\n            routeKeys,\n            keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,\n          })\n        } else {\n          return `/${escapeStringRegexp(segment)}`\n        }\n      })\n      .join(''),\n    routeKeys,\n  }\n}\n\n/**\n * This function extends `getRouteRegex` generating also a named regexp where\n * each group is named along with a routeKeys object that indexes the assigned\n * named group with its corresponding key. When the routeKeys need to be\n * prefixed to uniquely identify internally the \"prefixRouteKey\" arg should\n * be \"true\" currently this is only the case when creating the routes-manifest\n * during the build\n */\nexport function getNamedRouteRegex(\n  normalizedRoute: string,\n  prefixRouteKey: boolean\n) {\n  const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey)\n  return {\n    ...getRouteRegex(normalizedRoute),\n    namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n    routeKeys: result.routeKeys,\n  }\n}\n\n/**\n * Generates a named regexp.\n * This is intended to be using for build time only.\n */\nexport function getNamedMiddlewareRegex(\n  normalizedRoute: string,\n  options: {\n    catchAll?: boolean\n  }\n) {\n  const { parameterizedRoute } = getParametrizedRoute(normalizedRoute)\n  const { catchAll = true } = options\n  if (parameterizedRoute === '/') {\n    let catchAllRegex = catchAll ? '.*' : ''\n    return {\n      namedRegex: `^/${catchAllRegex}$`,\n    }\n  }\n\n  const { namedParameterizedRoute } = getNamedParametrizedRoute(\n    normalizedRoute,\n    false\n  )\n  let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''\n  return {\n    namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}