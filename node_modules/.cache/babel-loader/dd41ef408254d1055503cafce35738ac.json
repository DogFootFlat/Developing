{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return SideEffect;\n  }\n});\n\nconst _react = require(\"react\");\n\nconst isServer = typeof window === 'undefined';\nconst useClientOnlyLayoutEffect = isServer ? () => {} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? () => {} : _react.useEffect;\n\nfunction SideEffect(props) {\n  const {\n    headManager,\n    reduceComponentsToState\n  } = props;\n\n  function emitChange() {\n    if (headManager && headManager.mountedInstances) {\n      const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n\n      headManager.updateHead(reduceComponentsToState(headElements, props));\n    }\n  }\n\n  if (isServer) {\n    var _headManager_mountedInstances;\n\n    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n    emitChange();\n  }\n\n  useClientOnlyLayoutEffect(() => {\n    var _headManager_mountedInstances;\n\n    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n    return () => {\n      var _headManager_mountedInstances;\n\n      headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n    };\n  }); // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n  // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n  // being rendered, we only trigger the method from the last one.\n  // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n  // singleton in the layout effect pass, and actually trigger it in the effect pass.\n\n  useClientOnlyLayoutEffect(() => {\n    if (headManager) {\n      headManager._pendingUpdate = emitChange;\n    }\n\n    return () => {\n      if (headManager) {\n        headManager._pendingUpdate = emitChange;\n      }\n    };\n  });\n  useClientOnlyEffect(() => {\n    if (headManager && headManager._pendingUpdate) {\n      headManager._pendingUpdate();\n\n      headManager._pendingUpdate = null;\n    }\n\n    return () => {\n      if (headManager && headManager._pendingUpdate) {\n        headManager._pendingUpdate();\n\n        headManager._pendingUpdate = null;\n      }\n    };\n  });\n  return null;\n}","map":{"version":3,"mappings":";;;;;+BAoBA;kBAAA;;WAAwBA;;AAAxB;;uBAnB+D;;AAe/D,MAAMC,WAAW,OAAOC,MAAP,KAAkB,WAAnC;AACA,MAAMC,4BAA4BF,WAAW,OAAO,CAAlBA,GAAsBG,sBAAxD;AACA,MAAMC,sBAAsBJ,WAAW,OAAO,CAAlBA,GAAsBK,gBAAlD;;AAEe,SAASN,UAAT,CAAoBO,KAApB,EAA0C;EACvD,MAAM;IAAEC,WAAF;IAAeC;EAAf,IAA2CF,KAAjD;;EAEA,SAASG,UAAT,GAASA;IACP,IAAIF,eAAeA,YAAYG,gBAA/B,EAAiD;MAC/C,MAAMC,eAAeC,gBAASC,OAATD,CACnBE,MAAMC,IAAND,CAAWP,YAAYG,gBAAvBI,EAAiEE,MAAjEF,CACEG,OADFH,CADmBF,CAArB;;MAKAL,YAAYW,UAAZX,CAAuBC,wBAAwBG,YAAxBH,EAAsCF,KAAtCE,CAAvBD;IACF;EACF;;EAEA,IAAIP,QAAJ,EAAc;QACZO;;IAAAA,4EAAaG,gBAAbH,KAA6B,IAA7BA,GAA6B,MAA7BA,iCAA+BY,GAA/BZ,CAAmCD,MAAMc,QAAzCb;IACAE;EACF;;EAEAP,0BAA0B;QACxBK;;IAAAA,4EAAaG,gBAAbH,KAA6B,IAA7BA,GAA6B,MAA7BA,iCAA+BY,GAA/BZ,CAAmCD,MAAMc,QAAzCb;IACA,OAAO;UACLA;;MAAAA,4EAAaG,gBAAbH,KAA6B,IAA7BA,GAA6B,MAA7BA,iCAA+Bc,MAA/Bd,CAAsCD,MAAMc,QAA5Cb;IACF,CAFA;EAGF,CALAL,EAnBuD,CA0BvD;EACA;EACA;EACA;EACA;;EACAA,0BAA0B;IACxB,IAAIK,WAAJ,EAAiB;MACfA,YAAYe,cAAZf,GAA6BE,UAA7BF;IACF;;IACA,OAAO;MACL,IAAIA,WAAJ,EAAiB;QACfA,YAAYe,cAAZf,GAA6BE,UAA7BF;MACF;IACF,CAJA;EAKF,CATAL;EAWAE,oBAAoB;IAClB,IAAIG,eAAeA,YAAYe,cAA/B,EAA+C;MAC7Cf,YAAYe,cAAZf;;MACAA,YAAYe,cAAZf,GAA6B,IAA7BA;IACF;;IACA,OAAO;MACL,IAAIA,eAAeA,YAAYe,cAA/B,EAA+C;QAC7Cf,YAAYe,cAAZf;;QACAA,YAAYe,cAAZf,GAA6B,IAA7BA;MACF;IACF,CALA;EAMF,CAXAH;EAaA,OAAO,IAAP;AACF","names":["SideEffect","isServer","window","useClientOnlyLayoutEffect","useLayoutEffect","useClientOnlyEffect","useEffect","props","headManager","reduceComponentsToState","emitChange","mountedInstances","headElements","Children","toArray","Array","from","filter","Boolean","updateHead","add","children","delete","_pendingUpdate"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\shared\\lib\\side-effect.tsx"],"sourcesContent":["import type React from 'react'\nimport { Children, useEffect, useLayoutEffect, type JSX } from 'react'\n\ntype State = JSX.Element[] | undefined\n\nexport type SideEffectProps = {\n  reduceComponentsToState: <T extends {}>(\n    components: Array<React.ReactElement<any>>,\n    props: T\n  ) => State\n  handleStateChange?: (state: State) => void\n  headManager: any\n  inAmpMode?: boolean\n  children: React.ReactNode\n}\n\nconst isServer = typeof window === 'undefined'\nconst useClientOnlyLayoutEffect = isServer ? () => {} : useLayoutEffect\nconst useClientOnlyEffect = isServer ? () => {} : useEffect\n\nexport default function SideEffect(props: SideEffectProps) {\n  const { headManager, reduceComponentsToState } = props\n\n  function emitChange() {\n    if (headManager && headManager.mountedInstances) {\n      const headElements = Children.toArray(\n        Array.from(headManager.mountedInstances as Set<React.ReactNode>).filter(\n          Boolean\n        )\n      ) as React.ReactElement[]\n      headManager.updateHead(reduceComponentsToState(headElements, props))\n    }\n  }\n\n  if (isServer) {\n    headManager?.mountedInstances?.add(props.children)\n    emitChange()\n  }\n\n  useClientOnlyLayoutEffect(() => {\n    headManager?.mountedInstances?.add(props.children)\n    return () => {\n      headManager?.mountedInstances?.delete(props.children)\n    }\n  })\n\n  // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n  // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n  // being rendered, we only trigger the method from the last one.\n  // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n  // singleton in the layout effect pass, and actually trigger it in the effect pass.\n  useClientOnlyLayoutEffect(() => {\n    if (headManager) {\n      headManager._pendingUpdate = emitChange\n    }\n    return () => {\n      if (headManager) {\n        headManager._pendingUpdate = emitChange\n      }\n    }\n  })\n\n  useClientOnlyEffect(() => {\n    if (headManager && headManager._pendingUpdate) {\n      headManager._pendingUpdate()\n      headManager._pendingUpdate = null\n    }\n    return () => {\n      if (headManager && headManager._pendingUpdate) {\n        headManager._pendingUpdate()\n        headManager._pendingUpdate = null\n      }\n    }\n  })\n\n  return null\n}\n"]},"metadata":{},"sourceType":"script"}