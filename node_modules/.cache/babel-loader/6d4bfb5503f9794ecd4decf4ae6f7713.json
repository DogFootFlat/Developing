{"ast":null,"code":"\"use client\";\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Image\", {\n  enumerable: true,\n  get: function () {\n    return Image;\n  }\n});\n\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\n\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\n\nconst _jsxruntime = require(\"react/jsx-runtime\");\n\nconst _react = /*#__PURE__*/_interop_require_wildcard._(require(\"react\"));\n\nconst _reactdom = /*#__PURE__*/_interop_require_default._(require(\"react-dom\"));\n\nconst _head = /*#__PURE__*/_interop_require_default._(require(\"../shared/lib/head\"));\n\nconst _getimgprops = require(\"../shared/lib/get-img-props\");\n\nconst _imageconfig = require(\"../shared/lib/image-config\");\n\nconst _imageconfigcontextsharedruntime = require(\"../shared/lib/image-config-context.shared-runtime\");\n\nconst _warnonce = require(\"../shared/lib/utils/warn-once\");\n\nconst _routercontextsharedruntime = require(\"../shared/lib/router-context.shared-runtime\");\n\nconst _imageloader = /*#__PURE__*/_interop_require_default._(require(\"next/dist/shared/lib/image-loader\"));\n\nconst _usemergedref = require(\"./use-merged-ref\"); // This is replaced by webpack define plugin\n\n\nconst configEnv = process.env.__NEXT_IMAGE_OPTS;\n\nif (typeof window === 'undefined') {\n  globalThis.__NEXT_IMAGE_IMPORTED = true;\n} // See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\n\n\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n  const src = img == null ? void 0 : img.src;\n\n  if (!img || img['data-loaded-src'] === src) {\n    return;\n  }\n\n  img['data-loaded-src'] = src;\n  const p = 'decode' in img ? img.decode() : Promise.resolve();\n  p.catch(() => {}).then(() => {\n    if (!img.parentElement || !img.isConnected) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return;\n    }\n\n    if (placeholder !== 'empty') {\n      setBlurComplete(true);\n    }\n\n    if (onLoadRef == null ? void 0 : onLoadRef.current) {\n      // Since we don't have the SyntheticEvent here,\n      // we must create one with the same shape.\n      // See https://reactjs.org/docs/events.html\n      const event = new Event('load');\n      Object.defineProperty(event, 'target', {\n        writable: false,\n        value: img\n      });\n      let prevented = false;\n      let stopped = false;\n      onLoadRef.current({ ...event,\n        nativeEvent: event,\n        currentTarget: img,\n        target: img,\n        isDefaultPrevented: () => prevented,\n        isPropagationStopped: () => stopped,\n        persist: () => {},\n        preventDefault: () => {\n          prevented = true;\n          event.preventDefault();\n        },\n        stopPropagation: () => {\n          stopped = true;\n          event.stopPropagation();\n        }\n      });\n    }\n\n    if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n      onLoadingCompleteRef.current(img);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;\n\n      if (img.getAttribute('data-nimg') === 'fill') {\n        if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n          let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n\n          if (widthViewportRatio < 0.6) {\n            if (sizesInput === '100vw') {\n              (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n            } else {\n              (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n            }\n          }\n        }\n\n        if (img.parentElement) {\n          const {\n            position\n          } = window.getComputedStyle(img.parentElement);\n          const valid = ['absolute', 'fixed', 'relative'];\n\n          if (!valid.includes(position)) {\n            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(',') + \".\");\n          }\n        }\n\n        if (img.height === 0) {\n          (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n        }\n      }\n\n      const heightModified = img.height.toString() !== img.getAttribute('height');\n      const widthModified = img.width.toString() !== img.getAttribute('width');\n\n      if (heightModified && !widthModified || !heightModified && widthModified) {\n        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n      }\n    }\n  });\n}\n\nfunction getDynamicProps(fetchPriority) {\n  if (Boolean(_react.use)) {\n    // In React 19.0.0 or newer, we must use camelCase\n    // prop to avoid \"Warning: Invalid DOM property\".\n    // See https://github.com/facebook/react/pull/25927\n    return {\n      fetchPriority\n    };\n  } // In React 18.2.0 or older, we must use lowercase prop\n  // to avoid \"Warning: Invalid DOM property\".\n\n\n  return {\n    fetchpriority: fetchPriority\n  };\n}\n\nconst ImageElement = /*#__PURE__*/(0, _react.forwardRef)((param, forwardedRef) => {\n  let {\n    src,\n    srcSet,\n    sizes,\n    height,\n    width,\n    decoding,\n    className,\n    style,\n    fetchPriority,\n    placeholder,\n    loading,\n    unoptimized,\n    fill,\n    onLoadRef,\n    onLoadingCompleteRef,\n    setBlurComplete,\n    setShowAltText,\n    sizesInput,\n    onLoad,\n    onError,\n    ...rest\n  } = param;\n  const ownRef = (0, _react.useCallback)(img => {\n    if (!img) {\n      return;\n    }\n\n    if (onError) {\n      // If the image has an error before react hydrates, then the error is lost.\n      // The workaround is to wait until the image is mounted which is after hydration,\n      // then we set the src again to trigger the error handler (if there was an error).\n      // eslint-disable-next-line no-self-assign\n      img.src = img.src;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!src) {\n        console.error('Image is missing required \"src\" property:', img);\n      }\n\n      if (img.getAttribute('alt') === null) {\n        console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n      }\n    }\n\n    if (img.complete) {\n      handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n    }\n  }, [src, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, onError, unoptimized, sizesInput]);\n  const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);\n  return /*#__PURE__*/(0, _jsxruntime.jsx)(\"img\", { ...rest,\n    ...getDynamicProps(fetchPriority),\n    // It's intended to keep `loading` before `src` because React updates\n    // props in order which causes Safari/Firefox to not lazy load properly.\n    // See https://github.com/facebook/react/issues/25883\n    loading: loading,\n    width: width,\n    height: height,\n    decoding: decoding,\n    \"data-nimg\": fill ? 'fill' : '1',\n    className: className,\n    style: style,\n    // It's intended to keep `src` the last attribute because React updates\n    // attributes in order. If we keep `src` the first one, Safari will\n    // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n    // updated by React. That causes multiple unnecessary requests if `srcSet`\n    // and `sizes` are defined.\n    // This bug cannot be reproduced in Chrome or Firefox.\n    sizes: sizes,\n    srcSet: srcSet,\n    src: src,\n    ref: ref,\n    onLoad: event => {\n      const img = event.currentTarget;\n      handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n    },\n    onError: event => {\n      // if the real image fails to load, this will ensure \"alt\" is visible\n      setShowAltText(true);\n\n      if (placeholder !== 'empty') {\n        // If the real image fails to load, this will still remove the placeholder.\n        setBlurComplete(true);\n      }\n\n      if (onError) {\n        onError(event);\n      }\n    }\n  });\n});\n\nfunction ImagePreload(param) {\n  let {\n    isAppRouter,\n    imgAttributes\n  } = param;\n  const opts = {\n    as: 'image',\n    imageSrcSet: imgAttributes.srcSet,\n    imageSizes: imgAttributes.sizes,\n    crossOrigin: imgAttributes.crossOrigin,\n    referrerPolicy: imgAttributes.referrerPolicy,\n    ...getDynamicProps(imgAttributes.fetchPriority)\n  };\n\n  if (isAppRouter && _reactdom.default.preload) {\n    // See https://github.com/facebook/react/pull/26940\n    _reactdom.default.preload(imgAttributes.src, // @ts-expect-error TODO: upgrade to `@types/react-dom@18.3.x`\n    opts);\n\n    return null;\n  }\n\n  return /*#__PURE__*/(0, _jsxruntime.jsx)(_head.default, {\n    children: /*#__PURE__*/(0, _jsxruntime.jsx)(\"link\", {\n      rel: \"preload\",\n      // Note how we omit the `href` attribute, as it would only be relevant\n      // for browsers that do not support `imagesrcset`, and in those cases\n      // it would cause the incorrect image to be preloaded.\n      //\n      // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n      href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n      ...opts\n    }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n  });\n}\n\nconst Image = /*#__PURE__*/(0, _react.forwardRef)((props, forwardedRef) => {\n  const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext); // We're in the app directory if there is no pages router.\n\n  const isAppRouter = !pagesRouter;\n  const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n  const config = (0, _react.useMemo)(() => {\n    const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n    const allSizes = [...c.deviceSizes, ...c.imageSizes].sort((a, b) => a - b);\n    const deviceSizes = c.deviceSizes.sort((a, b) => a - b);\n    return { ...c,\n      allSizes,\n      deviceSizes\n    };\n  }, [configContext]);\n  const {\n    onLoad,\n    onLoadingComplete\n  } = props;\n  const onLoadRef = (0, _react.useRef)(onLoad);\n  (0, _react.useEffect)(() => {\n    onLoadRef.current = onLoad;\n  }, [onLoad]);\n  const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n  (0, _react.useEffect)(() => {\n    onLoadingCompleteRef.current = onLoadingComplete;\n  }, [onLoadingComplete]);\n  const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n  const [showAltText, setShowAltText] = (0, _react.useState)(false);\n  const {\n    props: imgAttributes,\n    meta: imgMeta\n  } = (0, _getimgprops.getImgProps)(props, {\n    defaultLoader: _imageloader.default,\n    imgConf: config,\n    blurComplete,\n    showAltText\n  });\n  return /*#__PURE__*/(0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n    children: [/*#__PURE__*/(0, _jsxruntime.jsx)(ImageElement, { ...imgAttributes,\n      unoptimized: imgMeta.unoptimized,\n      placeholder: imgMeta.placeholder,\n      fill: imgMeta.fill,\n      onLoadRef: onLoadRef,\n      onLoadingCompleteRef: onLoadingCompleteRef,\n      setBlurComplete: setBlurComplete,\n      setShowAltText: setShowAltText,\n      sizesInput: props.sizes,\n      ref: forwardedRef\n    }), imgMeta.priority ? /*#__PURE__*/(0, _jsxruntime.jsx)(ImagePreload, {\n      isAppRouter: isAppRouter,\n      imgAttributes: imgAttributes\n    }) : null]\n  });\n});\n\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;mBA0WaA;;;;;;;;;;;;;iEA7VI;;mDACW;;6BAYO;;;;sCAEV;;;;;;kCAKIC;;AAE7B,kD,CACA;;;AAEA,MAAIC,SAAOC,UAAW,IAAXA,CAAWC,iBAAtB;;IACIC,kBAAmBC;EACvBD;AAmBA,C,CACA;AACA;;;SASEE,cAAYC,6BAAQC;EACpB,MAAKD,MAAOA,GAAG,IAAC,IAAJA,GAAI,MAAJA,GAAsBA,IAAKE,GAAvC;;MACE;IACF;EACAF;;EACAA,yBAAsBA,GAAtB;EACAG,MAAEC,CAAK,GAAC,YAAeJ,GAAf,GAAeA,YAAf,GAAeK,iBAAvBF;UACM,MAACH,CAAIM;QACP,wCAAwC;MACxC;MACA;MACA;MACA;MACA;MACF;IACA;;QACEC,gBAAgB;MAClBA;IACA;;QACEC,gDAA+C;MAC/C;MACA;MACA;MACAC,WAAOC,aAAeC,MAAfD,CAAPD;YAAyCG,gBAAUD;QAAOE,QAAOb,OAAd;QAAkBa;MAAlB;MAEnD,IAAIC,YAAU,KAAd;MACAN,WAAUO,QAAVP;eACKG,SAAK,EACRK,QADQ;QAERC,kBAFQ;QAGRC,aAAQlB,KAHA;QAIRmB,WAJQ;QAKRC,0BAAsBC,SALd;QAMRC,oBAAgB,eANR;QAORC,iBAPQ;sBAQNF,EAAY;UACZV,SAAMY,OAANZ;UACFA;QACAa,CAXQ;uBAYI;UACVb,OAAMa,OAANb;UACFA;QACF;MAfU;IAiBZ;;QACEV,wBAAqBc,IAArBd,GAA6BD,MAA7BC,GAA6BD;MAC/BC;IACA;;QACEwB,OAAMC,IAAN,CAAMA,QAAN,KAAwBxB,cAAK;MAC7B,MAAIF,OAAI2B,OAAYC,GAAZD,CAAazB,GAAbyB,EAAa,UAAbA,EAA8BE,YAA9BF,CAAsCG,GAAtCH,CAAsC,KAAtCA,KAAsCzB,GAA9C;;UACEF,IAAI2B,YAAJ,CAAKI,WAAL,MAAsBC,QAAcA;YAClC,iBAAIC,eACEC,sBADN,GAC8BC;UAC9B,IAAIF,qBAAqBjC,4BAAKmC,KAAL,GAAKxC,iBAA9B;;cACEsC,kBAAID,GAAe;gBACjBI,wBACE;cAEJ,IAAOC,kBAAP,EAAO,sPAAP;mBACED;cAGF;YACF;UACF;QACA;;YACEpC,mBAAkB;UAClB,MAAMsC;YAAAA;UAAAA,IAAQ3C,0CAAd;gBAAe2C,SAAY,UAAZ,EAAqB,OAArB,EAAgC,UAAhC;;cAEbF,2BACG;YAIL;UACF;QACA;;YACEA;UAGF;QACF;MAEA;;MAEA,MAAMG,iBAAgBvC,GAAImC,OAAJnC,CAAUwC,QAAVxC,OAAyBA,GAAI2B,aAAJ3B,CAAiB,QAAjBA,CAA/C;MACA,MACGyC,gBAAkBzC,GAACuC,MAAD,CAACA,QAAD,OACjBE,iBAAkBF,OAAlBE,CAFJ;;UAIEL,oCACG,mBAA0BG;QAE/B;MACF;IACF;EACF;AAEA;;SAGMG,gBAAQC,eAAM;MAChBD;IACA;IACA;IACA;WAASE;MAAcA;IAAdA;EAEX,CANkB,CAOlB;EACA;;;SAASC;IAA6BA;EAA7BA;AAGX;;kBAIMC,GAAM,aAENC,CAAM,GACNZ,MACAa,WAFAD,EAGAE,QACAC,YADAD,KAEAL;EAgBF;IAAMO,GAAN;IAAMA,MAAN;IAAeC,KAAf;IAAeA,MAAf;IAAeA,KAAf;IACGpD,QADH;IACGA,SADH;IACGA,KADH;IACGA,aADH;IACGA,WADH;IACGA,OADH;IACGA,WADH;IACGA,IADH;IACGA,SADH;IACGA,oBADH;IACGA,eADH;IACGA,cADH;IACGA,UADH;IACGA,MADH;IACGA,OADH;IACGA;EADH,IACGA,KADH;QAEImD,MAAKnD,GAAK;QACR;MACF;IACA;;QACEqD;MACA;MACA;MACA;MACArD;MACFA;IACA;;QACEyB,OAAKvB,IAAL,CAAUoD,QAAV,KAAU;UACRC;QACFA;MACA;;UACEA,iBACG,KADHA,MACG;QAELA;MACF;IACA;;QACExD,cACEC;MAQJD;IAEF;GAhCY,GAkCVyD,KACAhD,aACAP,WACAM,sBACA8C,iBACAtB,SACAC,aACDA,WAzCW;EA8Cd,6BACE,aADF,EACGhC,YADH,EACGA,MADH;SAEQyD,aAAI,8BACP,GAAGC,IADI;IAER,iCAFQ;IAGR;IACA;IACAC;IACAxB,OAAOA,SANC;IAORY,YAPQ;IAQRC,cARQ;IASRY,kBATQ;IAURX,aAAWA,mBAVH;IAWRC,SAAOA,WAXC;IAYRA,YAZQ;IAaR;IACA;IACA;IACA;IACA;IACAW;IACAf,YAnBQ;IAoBR5C,MAAKA,QApBG;IAqBR4D,KAAKA,GArBG;IAsBRC,QAtBQ;UAuBN,WAAYpD;MACZZ,iBACEC,cADFD;MASFA;IACAsD,CAlCQ;WAmCN;MACAW;MACAA,cAAIR,MAAJ;;UACEA;QACAjD;QACFA;MACA;;UACE8C,SAAQ1C;QACV0C;MACF;;EA5CQ;AAkDhB,CAzHMN;;SAyHgBkB,aACTC,OACXC;EAKA;IAAMC,WAAN;IAAaD;EAAb,IAAaD,KAAb;QACEG,IAAI;IACJC,WADI;IAEJC,aAAYJ,aAAcN,OAFtB;IAGJW,yBAAaL,MAHT;IAIJM,0BAAgBN,YAJZ;IAKJM,cAAGf,eAAgBS,eALf;IAMN;EANM;;MASJO;IACAC;IAGEP;IAEFA,IAFEA;;IAGJ;EAEA;;sBAEI,oCAACQ;YAOCC,EAAI;MACJA,cADI;MAEJ;MACA;MACA;MACA;MACAC;MACCA,IAAGV,eAAI,OAAJA,GAAIW,SAAJX,GAAID,iBAPJ;MALF;IAKE;EAPLS,CAAD;AAyBC;;MAEHpF,KAAMwF,gBAAcC,uBAAWC;EAC/B,sEAA0D,cAA1D,EAD+BA,CAE/B;;EAEA,MAAMC,0BAAN;EACA,MAAMC,aAASC,cAAOJ,UAAPI,EAAQC,mDAARD,CAAf;QACED,MAAMG,GAAI7F,oBAAayF;IACvB,MAAMK,aAAW,iBAAXA,IAAWC,+BAAjB;kBAAuBC,OAAgBH,EAAEhB,WAAlBmB,EAA8BC,GAAKJ,CAACK,WAApCF,EACvBC,IADuBD,CACjBA,eADiBA;IAEvB,iBAAO,sCAAP;WAAYH,EAAGC,IAAHD;MAAaG,QAAbH;MAAyBG;IAAzBH;GAHF7F,GAIMyF,cAJNzF;EAOZ,MAAMc;IAAAA;IAAAA;EAAAA,IAAmBuD,KAAzB;EAEA8B,sBAAUC,aAAVD,EAAU9B,MAAV8B;MACErF,kBAAiB,MAAGuD;IACnBvD;MAAQuD;EAIX8B,0BAAU,wCAAVA;MACE5F,wBAAqBc;IACpBd;MAAmB8F;EAGtB,MAAM,CAACC,YAAD,EAAchC,eAAd,IAAgCiC,qBAAS,KAATA,CAAtC;EAEA,MAAM,cAAS9B,cAAT,IAA8B+B,UAAYC,SAAZD,EAAYC,KAAZD,CAApC;QACEE;IAAAA;IAAAA;EAAAA,IAAa;IACbC,aAASjB,sBADI;IAEbkB,eAFa;IAGbN,YAHa;IAIfA;EAJe;;4BAUH7B,eAAa,IAAbA,EAAaoC,YAAbpC,EAAa,EACjBpC,gBADiB;MAEjByB,aAAa0C,QAAQ1C,WAFJ;MAGjBgD,WAAMN,SAAY,YAHD;MAIjB1F,aAAWA,KAJM;MAKjBP,oBALiB;MAMjBM,oBAAiBA,sBANA;MAOjByD,iBAAgBA,eAPC;MAQjBhC,cAAYyE,gBARK;MASjB3C,UAAK4C,aATY;;IAAA,CAAbvC,UAcJO,YAAaA;MACbP,wBADaO;mBAGb;IAHaA;;CArDDO","names":["Image","_interop_require_default","configEnv","window","__NEXT_IMAGE_OPTS","globalThis","__NEXT_IMAGE_IMPORTED","handleLoading","img","onLoadingCompleteRef","src","p","catch","Promise","parentElement","setBlurComplete","onLoadRef","Object","defineProperty","event","writable","value","stopped","current","nativeEvent","currentTarget","target","isDefaultPrevented","isPropagationStopped","prevented","persist","preventDefault","stopPropagation","process","origSrc","getAttribute","URL","searchParams","get","unoptimized","sizesInput","widthViewportRatio","getBoundingClientRect","width","warnOnce","_warnonce","valid","widthModified","toString","heightModified","Boolean","use","fetchPriority","fetchpriority","srcSet","height","decoding","className","style","ownRef","useCallback","onError","NODE_ENV","console","placeholder","rest","getDynamicProps","loading","data-nimg","sizes","ref","onLoad","setShowAltText","ImagePreload","param","imgAttributes","opts","as","imageSrcSet","imageSizes","crossOrigin","referrerPolicy","isAppRouter","ReactDOM","link","rel","href","undefined","pagesRouter","useContext","RouterContext","configContext","config","useMemo","_imageconfigcontextsharedruntime","c","allSizes","_imageconfig","deviceSizes","sort","a","useEffect","_react","onLoadingComplete","showAltText","useState","imgMeta","getImgProps","defaultLoader","imgConf","blurComplete","ImageElement","fill","props","forwardedRef"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\client\\image-component.tsx"],"sourcesContent":["'use client'\n\nimport React, {\n  useRef,\n  useEffect,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n  forwardRef,\n  use,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport Head from '../shared/lib/head'\nimport { getImgProps } from '../shared/lib/get-img-props'\nimport type {\n  ImageProps,\n  ImgProps,\n  OnLoad,\n  OnLoadingComplete,\n  PlaceholderValue,\n} from '../shared/lib/get-img-props'\nimport type {\n  ImageConfigComplete,\n  ImageLoaderProps,\n} from '../shared/lib/image-config'\nimport { imageConfigDefault } from '../shared/lib/image-config'\nimport { ImageConfigContext } from '../shared/lib/image-config-context.shared-runtime'\nimport { warnOnce } from '../shared/lib/utils/warn-once'\nimport { RouterContext } from '../shared/lib/router-context.shared-runtime'\n\n// @ts-ignore - This is replaced by webpack alias\nimport defaultLoader from 'next/dist/shared/lib/image-loader'\nimport { useMergedRef } from './use-merged-ref'\n\n// This is replaced by webpack define plugin\nconst configEnv = process.env.__NEXT_IMAGE_OPTS as any as ImageConfigComplete\n\nif (typeof window === 'undefined') {\n  ;(globalThis as any).__NEXT_IMAGE_IMPORTED = true\n}\n\nexport type { ImageLoaderProps }\nexport type ImageLoader = (p: ImageLoaderProps) => string\n\ntype ImgElementWithDataProp = HTMLImageElement & {\n  'data-loaded-src': string | undefined\n}\n\ntype ImageElementProps = ImgProps & {\n  unoptimized: boolean\n  placeholder: PlaceholderValue\n  onLoadRef: React.MutableRefObject<OnLoad | undefined>\n  onLoadingCompleteRef: React.MutableRefObject<OnLoadingComplete | undefined>\n  setBlurComplete: (b: boolean) => void\n  setShowAltText: (b: boolean) => void\n  sizesInput: string | undefined\n}\n\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(\n  img: ImgElementWithDataProp,\n  placeholder: PlaceholderValue,\n  onLoadRef: React.MutableRefObject<OnLoad | undefined>,\n  onLoadingCompleteRef: React.MutableRefObject<OnLoadingComplete | undefined>,\n  setBlurComplete: (b: boolean) => void,\n  unoptimized: boolean,\n  sizesInput: string | undefined\n) {\n  const src = img?.src\n  if (!img || img['data-loaded-src'] === src) {\n    return\n  }\n  img['data-loaded-src'] = src\n  const p = 'decode' in img ? img.decode() : Promise.resolve()\n  p.catch(() => {}).then(() => {\n    if (!img.parentElement || !img.isConnected) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return\n    }\n    if (placeholder !== 'empty') {\n      setBlurComplete(true)\n    }\n    if (onLoadRef?.current) {\n      // Since we don't have the SyntheticEvent here,\n      // we must create one with the same shape.\n      // See https://reactjs.org/docs/events.html\n      const event = new Event('load')\n      Object.defineProperty(event, 'target', { writable: false, value: img })\n      let prevented = false\n      let stopped = false\n      onLoadRef.current({\n        ...event,\n        nativeEvent: event,\n        currentTarget: img,\n        target: img,\n        isDefaultPrevented: () => prevented,\n        isPropagationStopped: () => stopped,\n        persist: () => {},\n        preventDefault: () => {\n          prevented = true\n          event.preventDefault()\n        },\n        stopPropagation: () => {\n          stopped = true\n          event.stopPropagation()\n        },\n      })\n    }\n    if (onLoadingCompleteRef?.current) {\n      onLoadingCompleteRef.current(img)\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      const origSrc = new URL(src, 'http://n').searchParams.get('url') || src\n      if (img.getAttribute('data-nimg') === 'fill') {\n        if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n          let widthViewportRatio =\n            img.getBoundingClientRect().width / window.innerWidth\n          if (widthViewportRatio < 0.6) {\n            if (sizesInput === '100vw') {\n              warnOnce(\n                `Image with src \"${origSrc}\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`\n              )\n            } else {\n              warnOnce(\n                `Image with src \"${origSrc}\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`\n              )\n            }\n          }\n        }\n        if (img.parentElement) {\n          const { position } = window.getComputedStyle(img.parentElement)\n          const valid = ['absolute', 'fixed', 'relative']\n          if (!valid.includes(position)) {\n            warnOnce(\n              `Image with src \"${origSrc}\" has \"fill\" and parent element with invalid \"position\". Provided \"${position}\" should be one of ${valid\n                .map(String)\n                .join(',')}.`\n            )\n          }\n        }\n        if (img.height === 0) {\n          warnOnce(\n            `Image with src \"${origSrc}\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.`\n          )\n        }\n      }\n\n      const heightModified =\n        img.height.toString() !== img.getAttribute('height')\n      const widthModified = img.width.toString() !== img.getAttribute('width')\n      if (\n        (heightModified && !widthModified) ||\n        (!heightModified && widthModified)\n      ) {\n        warnOnce(\n          `Image with src \"${origSrc}\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio.`\n        )\n      }\n    }\n  })\n}\n\nfunction getDynamicProps(\n  fetchPriority?: string\n): Record<string, string | undefined> {\n  if (Boolean(use)) {\n    // In React 19.0.0 or newer, we must use camelCase\n    // prop to avoid \"Warning: Invalid DOM property\".\n    // See https://github.com/facebook/react/pull/25927\n    return { fetchPriority }\n  }\n  // In React 18.2.0 or older, we must use lowercase prop\n  // to avoid \"Warning: Invalid DOM property\".\n  return { fetchpriority: fetchPriority }\n}\n\nconst ImageElement = forwardRef<HTMLImageElement | null, ImageElementProps>(\n  (\n    {\n      src,\n      srcSet,\n      sizes,\n      height,\n      width,\n      decoding,\n      className,\n      style,\n      fetchPriority,\n      placeholder,\n      loading,\n      unoptimized,\n      fill,\n      onLoadRef,\n      onLoadingCompleteRef,\n      setBlurComplete,\n      setShowAltText,\n      sizesInput,\n      onLoad,\n      onError,\n      ...rest\n    },\n    forwardedRef\n  ) => {\n    const ownRef = useCallback(\n      (img: ImgElementWithDataProp | null) => {\n        if (!img) {\n          return\n        }\n        if (onError) {\n          // If the image has an error before react hydrates, then the error is lost.\n          // The workaround is to wait until the image is mounted which is after hydration,\n          // then we set the src again to trigger the error handler (if there was an error).\n          // eslint-disable-next-line no-self-assign\n          img.src = img.src\n        }\n        if (process.env.NODE_ENV !== 'production') {\n          if (!src) {\n            console.error(`Image is missing required \"src\" property:`, img)\n          }\n          if (img.getAttribute('alt') === null) {\n            console.error(\n              `Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.`\n            )\n          }\n        }\n        if (img.complete) {\n          handleLoading(\n            img,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            unoptimized,\n            sizesInput\n          )\n        }\n      },\n      [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput,\n      ]\n    )\n\n    const ref = useMergedRef(forwardedRef, ownRef)\n\n    return (\n      <img\n        {...rest}\n        {...getDynamicProps(fetchPriority)}\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading={loading}\n        width={width}\n        height={height}\n        decoding={decoding}\n        data-nimg={fill ? 'fill' : '1'}\n        className={className}\n        style={style}\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes={sizes}\n        srcSet={srcSet}\n        src={src}\n        ref={ref}\n        onLoad={(event) => {\n          const img = event.currentTarget as ImgElementWithDataProp\n          handleLoading(\n            img,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            unoptimized,\n            sizesInput\n          )\n        }}\n        onError={(event) => {\n          // if the real image fails to load, this will ensure \"alt\" is visible\n          setShowAltText(true)\n          if (placeholder !== 'empty') {\n            // If the real image fails to load, this will still remove the placeholder.\n            setBlurComplete(true)\n          }\n          if (onError) {\n            onError(event)\n          }\n        }}\n      />\n    )\n  }\n)\n\nfunction ImagePreload({\n  isAppRouter,\n  imgAttributes,\n}: {\n  isAppRouter: boolean\n  imgAttributes: ImgProps\n}) {\n  const opts = {\n    as: 'image',\n    imageSrcSet: imgAttributes.srcSet,\n    imageSizes: imgAttributes.sizes,\n    crossOrigin: imgAttributes.crossOrigin,\n    referrerPolicy: imgAttributes.referrerPolicy,\n    ...getDynamicProps(imgAttributes.fetchPriority),\n  }\n\n  if (isAppRouter && ReactDOM.preload) {\n    // See https://github.com/facebook/react/pull/26940\n    ReactDOM.preload(\n      imgAttributes.src,\n      // @ts-expect-error TODO: upgrade to `@types/react-dom@18.3.x`\n      opts\n    )\n    return null\n  }\n\n  return (\n    <Head>\n      <link\n        key={\n          '__nimg-' +\n          imgAttributes.src +\n          imgAttributes.srcSet +\n          imgAttributes.sizes\n        }\n        rel=\"preload\"\n        // Note how we omit the `href` attribute, as it would only be relevant\n        // for browsers that do not support `imagesrcset`, and in those cases\n        // it would cause the incorrect image to be preloaded.\n        //\n        // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n        href={imgAttributes.srcSet ? undefined : imgAttributes.src}\n        {...opts}\n      />\n    </Head>\n  )\n}\n\n/**\n * The `Image` component is used to optimize images.\n *\n * Read more: [Next.js docs: `Image`](https://nextjs.org/docs/app/api-reference/components/image)\n */\nexport const Image = forwardRef<HTMLImageElement | null, ImageProps>(\n  (props, forwardedRef) => {\n    const pagesRouter = useContext(RouterContext)\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter\n\n    const configContext = useContext(ImageConfigContext)\n    const config = useMemo(() => {\n      const c = configEnv || configContext || imageConfigDefault\n      const allSizes = [...c.deviceSizes, ...c.imageSizes].sort((a, b) => a - b)\n      const deviceSizes = c.deviceSizes.sort((a, b) => a - b)\n      return { ...c, allSizes, deviceSizes }\n    }, [configContext])\n\n    const { onLoad, onLoadingComplete } = props\n    const onLoadRef = useRef(onLoad)\n\n    useEffect(() => {\n      onLoadRef.current = onLoad\n    }, [onLoad])\n\n    const onLoadingCompleteRef = useRef(onLoadingComplete)\n\n    useEffect(() => {\n      onLoadingCompleteRef.current = onLoadingComplete\n    }, [onLoadingComplete])\n\n    const [blurComplete, setBlurComplete] = useState(false)\n    const [showAltText, setShowAltText] = useState(false)\n\n    const { props: imgAttributes, meta: imgMeta } = getImgProps(props, {\n      defaultLoader,\n      imgConf: config,\n      blurComplete,\n      showAltText,\n    })\n\n    return (\n      <>\n        {\n          <ImageElement\n            {...imgAttributes}\n            unoptimized={imgMeta.unoptimized}\n            placeholder={imgMeta.placeholder}\n            fill={imgMeta.fill}\n            onLoadRef={onLoadRef}\n            onLoadingCompleteRef={onLoadingCompleteRef}\n            setBlurComplete={setBlurComplete}\n            setShowAltText={setShowAltText}\n            sizesInput={props.sizes}\n            ref={forwardedRef}\n          />\n        }\n        {imgMeta.priority ? (\n          <ImagePreload\n            isAppRouter={isAppRouter}\n            imgAttributes={imgAttributes}\n          />\n        ) : null}\n      </>\n    )\n  }\n)\n"]},"metadata":{},"sourceType":"script"}