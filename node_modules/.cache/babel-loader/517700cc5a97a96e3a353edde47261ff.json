{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  INTERCEPTION_ROUTE_MARKERS: null,\n  extractInterceptionRouteInformation: null,\n  isInterceptionRouteAppPath: null\n});\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  INTERCEPTION_ROUTE_MARKERS: function () {\n    return INTERCEPTION_ROUTE_MARKERS;\n  },\n  extractInterceptionRouteInformation: function () {\n    return extractInterceptionRouteInformation;\n  },\n  isInterceptionRouteAppPath: function () {\n    return isInterceptionRouteAppPath;\n  }\n});\n\nconst _apppaths = require(\"../../shared/lib/router/utils/app-paths\");\n\nconst INTERCEPTION_ROUTE_MARKERS = ['(..)(..)', '(.)', '(..)', '(...)'];\n\nfunction isInterceptionRouteAppPath(path) {\n  // TODO-APP: add more serious validation\n  return path.split('/').find(segment => INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m))) !== undefined;\n}\n\nfunction extractInterceptionRouteInformation(path) {\n  let interceptingRoute, marker, interceptedRoute;\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n\n    if (marker) {\n      [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n      break;\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n  }\n\n  interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n  ;\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`;\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute;\n      }\n\n      break;\n\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n      }\n\n      interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\n      break;\n\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute;\n      break;\n\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n      const splitInterceptingRoute = interceptingRoute.split('/');\n\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n      }\n\n      interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\n      break;\n\n    default:\n      throw new Error('Invariant: unexpected marker');\n  }\n\n  return {\n    interceptingRoute,\n    interceptedRoute\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;EAGaA,0BAA0B;WAA1BA;;EAkBGC,mCAAmC;WAAnCA;;EAXAC,0BAA0B;WAA1BA;;;;0BAViB;;AAG1B,MAAMF,6BAA6B,CACxC,UADwC,EAExC,KAFwC,EAGxC,MAHwC,EAIxC,OAJwC,CAAnC;;AAOA,SAASE,0BAAT,CAAoCC,IAApC,EAAgD;EACrD;EACA,OACEA,KACGC,KADHD,CACS,GADTA,EAEGE,IAFHF,CAESG,OAAD,IACJN,2BAA2BK,IAA3BL,CAAiCO,CAAD,IAAOD,QAAQE,UAARF,CAAmBC,CAAnBD,CAAvCN,CAHJG,MAIQM,SALV;AAOF;;AAEO,SAASR,mCAAT,CAA6CE,IAA7C,EAAyD;EAC9D,IAAIO,iBAAJ,EACEC,MADF,EAEEC,gBAFF;;EAIA,KAAK,MAAMN,OAAX,IAAsBH,KAAKC,KAALD,CAAW,GAAXA,CAAtB,EAAuC;IACrCQ,SAASX,2BAA2BK,IAA3BL,CAAiCO,CAAD,IAAOD,QAAQE,UAARF,CAAmBC,CAAnBD,CAAvCN,CAATW;;IACA,IAAIA,MAAJ,EAAY;MACT,CAACD,iBAAD,EAAoBE,gBAApB,IAAwCT,KAAKC,KAALD,CAAWQ,MAAXR,EAAmB,CAAnBA,CAAxC;MACD;IACF;EACF;;EAEA,IAAI,CAACO,iBAAD,IAAsB,CAACC,MAAvB,IAAiC,CAACC,gBAAtC,EAAwD;IACtD,MAAM,IAAIC,KAAJ,CACH,+BAA8BV,IAAK,mFADhC,CAAN;EAGF;;EAEAO,oBAAoBI,gCAAiBJ,iBAAjBI,CAApBJ,CAAwD;EAAxDA;;EAEA,QAAQC,MAAR;IACE,KAAK,KAAL;MACE;MACA,IAAID,sBAAsB,GAA1B,EAA+B;QAC7BE,mBAAoB,IAAGA,gBAAiB,EAAxCA;MACF,CAFA,MAEO;QACLA,mBAAmBF,oBAAoB,GAApBA,GAA0BE,gBAA7CA;MACF;;MACA;;IACF,KAAK,MAAL;MACE;MACA,IAAIF,sBAAsB,GAA1B,EAA+B;QAC7B,MAAM,IAAIG,KAAJ,CACH,+BAA8BV,IAAK,8DADhC,CAAN;MAGF;;MACAS,mBAAmBF,kBAChBN,KADgBM,CACV,GADUA,EAEhBK,KAFgBL,CAEV,CAFUA,EAEP,CAAC,CAFMA,EAGhBM,MAHgBN,CAGTE,gBAHSF,EAIhBO,IAJgBP,CAIX,GAJWA,CAAnBE;MAKA;;IACF,KAAK,OAAL;MACE;MACAA,mBAAmB,MAAMA,gBAAzBA;MACA;;IACF,KAAK,UAAL;MACE;MAEA,MAAMM,yBAAyBR,kBAAkBN,KAAlBM,CAAwB,GAAxBA,CAA/B;;MACA,IAAIQ,uBAAuBC,MAAvBD,IAAiC,CAArC,EAAwC;QACtC,MAAM,IAAIL,KAAJ,CACH,+BAA8BV,IAAK,iEADhC,CAAN;MAGF;;MAEAS,mBAAmBM,uBAChBH,KADgBG,CACV,CADUA,EACP,CAAC,CADMA,EAEhBF,MAFgBE,CAETN,gBAFSM,EAGhBD,IAHgBC,CAGX,GAHWA,CAAnBN;MAIA;;IACF;MACE,MAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN;EA1CJ;;EA6CA,OAAO;IAAEH,iBAAF;IAAqBE;EAArB,CAAP;AACF","names":["INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","path","split","find","segment","m","startsWith","undefined","interceptingRoute","marker","interceptedRoute","Error","normalizeAppPath","slice","concat","join","splitInterceptingRoute","length"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\server\\lib\\interception-routes.ts"],"sourcesContent":["import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\nexport function extractInterceptionRouteInformation(path: string) {\n  let interceptingRoute: string | undefined,\n    marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n    interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n"]},"metadata":{},"sourceType":"script"}