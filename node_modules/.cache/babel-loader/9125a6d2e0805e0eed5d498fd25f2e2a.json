{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"useIntersection\", {\n  enumerable: true,\n  get: function () {\n    return useIntersection;\n  }\n});\n\nconst _react = require(\"react\");\n\nconst _requestidlecallback = require(\"./request-idle-callback\");\n\nconst hasIntersectionObserver = typeof IntersectionObserver === 'function';\nconst observers = new Map();\nconst idList = [];\n\nfunction createObserver(options) {\n  const id = {\n    root: options.root || null,\n    margin: options.rootMargin || ''\n  };\n  const existing = idList.find(obj => obj.root === id.root && obj.margin === id.margin);\n  let instance;\n\n  if (existing) {\n    instance = observers.get(existing);\n\n    if (instance) {\n      return instance;\n    }\n  }\n\n  const elements = new Map();\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const callback = elements.get(entry.target);\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  instance = {\n    id,\n    observer,\n    elements\n  };\n  idList.push(id);\n  observers.set(id, instance);\n  return instance;\n}\n\nfunction observe(element, callback, options) {\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options);\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      const index = idList.findIndex(obj => obj.root === id.root && obj.margin === id.margin);\n\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\n\nfunction useIntersection(param) {\n  let {\n    rootRef,\n    rootMargin,\n    disabled\n  } = param;\n  const isDisabled = disabled || !hasIntersectionObserver;\n  const [visible, setVisible] = (0, _react.useState)(false);\n  const elementRef = (0, _react.useRef)(null);\n  const setElement = (0, _react.useCallback)(element => {\n    elementRef.current = element;\n  }, []);\n  (0, _react.useEffect)(() => {\n    if (hasIntersectionObserver) {\n      if (isDisabled || visible) return;\n      const element = elementRef.current;\n\n      if (element && element.tagName) {\n        const unobserve = observe(element, isVisible => isVisible && setVisible(isVisible), {\n          root: rootRef == null ? void 0 : rootRef.current,\n          rootMargin\n        });\n        return unobserve;\n      }\n    } else {\n      if (!visible) {\n        const idleCallback = (0, _requestidlecallback.requestIdleCallback)(() => setVisible(true));\n        return () => (0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [isDisabled, rootMargin, rootRef, visible, elementRef.current]);\n  const resetVisible = (0, _react.useCallback)(() => {\n    setVisible(false);\n  }, []);\n  return [setElement, visible, resetVisible];\n}\n\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"mappings":"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","names":["useIntersection","hasIntersectionObserver","IntersectionObserver","observers","Map","idList","createObserver","options","id","root","margin","rootMargin","existing","find","obj","instance","get","elements","observer","entries","forEach","entry","callback","target","isVisible","isIntersecting","intersectionRatio","push","set","observe","element","unobserve","delete","size","disconnect","index","findIndex","splice","param","rootRef","disabled","isDisabled","visible","setVisible","useState","elementRef","useRef","setElement","useCallback","current","useEffect","tagName","idleCallback","requestIdleCallback","cancelIdleCallback","resetVisible"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\client\\use-intersection.tsx"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport {\n  requestIdleCallback,\n  cancelIdleCallback,\n} from './request-idle-callback'\n\ntype UseIntersectionObserverInit = Pick<\n  IntersectionObserverInit,\n  'rootMargin' | 'root'\n>\n\ntype UseIntersection = { disabled?: boolean } & UseIntersectionObserverInit & {\n    rootRef?: React.RefObject<HTMLElement | null> | null\n  }\ntype ObserveCallback = (isVisible: boolean) => void\ntype Identifier = {\n  root: Element | Document | null\n  margin: string\n}\ntype Observer = {\n  id: Identifier\n  observer: IntersectionObserver\n  elements: Map<Element, ObserveCallback>\n}\n\nconst hasIntersectionObserver = typeof IntersectionObserver === 'function'\n\nconst observers = new Map<Identifier, Observer>()\nconst idList: Identifier[] = []\n\nfunction createObserver(options: UseIntersectionObserverInit): Observer {\n  const id = {\n    root: options.root || null,\n    margin: options.rootMargin || '',\n  }\n  const existing = idList.find(\n    (obj) => obj.root === id.root && obj.margin === id.margin\n  )\n  let instance: Observer | undefined\n\n  if (existing) {\n    instance = observers.get(existing)\n    if (instance) {\n      return instance\n    }\n  }\n\n  const elements = new Map<Element, ObserveCallback>()\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      const callback = elements.get(entry.target)\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0\n      if (callback && isVisible) {\n        callback(isVisible)\n      }\n    })\n  }, options)\n  instance = {\n    id,\n    observer,\n    elements,\n  }\n\n  idList.push(id)\n  observers.set(id, instance)\n  return instance\n}\n\nfunction observe(\n  element: Element,\n  callback: ObserveCallback,\n  options: UseIntersectionObserverInit\n): () => void {\n  const { id, observer, elements } = createObserver(options)\n  elements.set(element, callback)\n\n  observer.observe(element)\n  return function unobserve(): void {\n    elements.delete(element)\n    observer.unobserve(element)\n\n    // Destroy observer when there's nothing left to watch:\n    if (elements.size === 0) {\n      observer.disconnect()\n      observers.delete(id)\n      const index = idList.findIndex(\n        (obj) => obj.root === id.root && obj.margin === id.margin\n      )\n      if (index > -1) {\n        idList.splice(index, 1)\n      }\n    }\n  }\n}\n\nexport function useIntersection<T extends Element>({\n  rootRef,\n  rootMargin,\n  disabled,\n}: UseIntersection): [(element: T | null) => void, boolean, () => void] {\n  const isDisabled: boolean = disabled || !hasIntersectionObserver\n\n  const [visible, setVisible] = useState(false)\n  const elementRef = useRef<T | null>(null)\n  const setElement = useCallback((element: T | null) => {\n    elementRef.current = element\n  }, [])\n\n  useEffect(() => {\n    if (hasIntersectionObserver) {\n      if (isDisabled || visible) return\n\n      const element = elementRef.current\n      if (element && element.tagName) {\n        const unobserve = observe(\n          element,\n          (isVisible) => isVisible && setVisible(isVisible),\n          { root: rootRef?.current, rootMargin }\n        )\n\n        return unobserve\n      }\n    } else {\n      if (!visible) {\n        const idleCallback = requestIdleCallback(() => setVisible(true))\n        return () => cancelIdleCallback(idleCallback)\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled, rootMargin, rootRef, visible, elementRef.current])\n\n  const resetVisible = useCallback(() => {\n    setVisible(false)\n  }, [])\n\n  return [setElement, visible, resetVisible]\n}\n"]},"metadata":{},"sourceType":"script"}