{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getRouteMatcher\", {\n  enumerable: true,\n  get: function () {\n    return getRouteMatcher;\n  }\n});\n\nconst _utils = require(\"../../utils\");\n\nfunction getRouteMatcher(param) {\n  let {\n    re,\n    groups\n  } = param;\n  return pathname => {\n    const routeMatch = re.exec(pathname);\n\n    if (!routeMatch) {\n      return false;\n    }\n\n    const decode = param => {\n      try {\n        return decodeURIComponent(param);\n      } catch (_) {\n        throw new _utils.DecodeError('failed to decode param');\n      }\n    };\n\n    const params = {};\n    Object.keys(groups).forEach(slugName => {\n      const g = groups[slugName];\n      const m = routeMatch[g.pos];\n\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/') ? m.split('/').map(entry => decode(entry)) : g.repeat ? [decode(m)] : decode(m);\n      }\n    });\n    return params;\n  };\n}","map":{"version":3,"mappings":";;;;;+BAQgBA;kBAAAA;;WAAAA;;AAAAA;;uBAPY;;AAOrB,SAASA,eAAT,CAAyBC,KAAzB,EAAmD;EAA1B;IAAEC,EAAF;IAAMC;EAAN;EAC9B,OAAQC,QAAD,IAACA;IACN,MAAMC,aAAaH,GAAGI,IAAHJ,CAAQE,QAARF,CAAnB;;IACA,IAAI,CAACG,UAAL,EAAiB;MACf,OAAO,KAAP;IACF;;IAEA,MAAME,SAAUN,KAAD,IAACA;MACd,IAAI;QACF,OAAOO,mBAAmBP,KAAnBO,CAAP;MACF,CAFA,CAEE,OAAOC,CAAP,EAAU;QACV,MAAM,IAAIC,kBAAJ,CAAgB,wBAAhB,CAAN;MACF;IACF,CANA;;IAOA,MAAMC,SAAqD,EAA3D;IAEAC,OAAOC,IAAPD,CAAYT,MAAZS,EAAoBE,OAApBF,CAA6BG,QAAD,IAACA;MAC3B,MAAMC,IAAIb,MAAM,CAACY,QAAD,CAAhB;MACA,MAAME,IAAIZ,UAAU,CAACW,EAAEE,GAAH,CAApB;;MACA,IAAID,MAAME,SAAV,EAAqB;QACnBR,MAAM,CAACI,QAAD,CAANJ,GAAmB,CAACM,EAAEG,OAAFH,CAAU,GAAVA,CAAD,GACfA,EAAEI,KAAFJ,CAAQ,GAARA,EAAaK,GAAbL,CAAkBM,KAAD,IAAWhB,OAAOgB,KAAPhB,CAA5BU,CADe,GAEfD,EAAEQ,MAAFR,GACE,CAACT,OAAOU,CAAPV,CAAD,CADFS,GAEET,OAAOU,CAAPV,CAJNI;MAKF;IACF,CAVAC;IAWA,OAAOD,MAAP;EACF,CA3BA;AA4BF","names":["getRouteMatcher","param","re","groups","pathname","routeMatch","exec","decode","decodeURIComponent","_","DecodeError","params","Object","keys","forEach","slugName","g","m","pos","undefined","indexOf","split","map","entry","repeat"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\shared\\lib\\router\\utils\\route-matcher.ts"],"sourcesContent":["import type { RouteRegex } from './route-regex'\nimport { DecodeError } from '../../utils'\nimport type { Params } from '../../../../server/request/params'\n\nexport interface RouteMatchFn {\n  (pathname: string | null | undefined): false | Params\n}\n\nexport function getRouteMatcher({ re, groups }: RouteRegex): RouteMatchFn {\n  return (pathname: string | null | undefined) => {\n    const routeMatch = re.exec(pathname!)\n    if (!routeMatch) {\n      return false\n    }\n\n    const decode = (param: string) => {\n      try {\n        return decodeURIComponent(param)\n      } catch (_) {\n        throw new DecodeError('failed to decode param')\n      }\n    }\n    const params: { [paramName: string]: string | string[] } = {}\n\n    Object.keys(groups).forEach((slugName: string) => {\n      const g = groups[slugName]\n      const m = routeMatch[g.pos]\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/')\n          ? m.split('/').map((entry) => decode(entry))\n          : g.repeat\n            ? [decode(m)]\n            : decode(m)\n      }\n    })\n    return params\n  }\n}\n"]},"metadata":{},"sourceType":"script"}