{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"resolveHref\", {\n  enumerable: true,\n  get: function () {\n    return resolveHref;\n  }\n});\n\nconst _querystring = require(\"../shared/lib/router/utils/querystring\");\n\nconst _formaturl = require(\"../shared/lib/router/utils/format-url\");\n\nconst _omit = require(\"../shared/lib/router/utils/omit\");\n\nconst _utils = require(\"../shared/lib/utils\");\n\nconst _normalizetrailingslash = require(\"./normalize-trailing-slash\");\n\nconst _islocalurl = require(\"../shared/lib/router/utils/is-local-url\");\n\nconst _utils1 = require(\"../shared/lib/router/utils\");\n\nconst _interpolateas = require(\"../shared/lib/router/utils/interpolate-as\");\n\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === 'string' ? href : (0, _formaturl.formatWithValidation)(href); // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split('?', 1);\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n    const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  } // Return because it cannot be routed by the Next.js router\n\n\n  if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = '';\n\n    if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n\n      if (result) {\n        interpolatedAs = (0, _formaturl.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: (0, _omit.omit)(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"mappings":";;;;;+BAyBgBA;kBAAAA;;WAAAA;;AAAAA;;6BAvBuB;;2BACF;;sBAChB;;uBACoB;;wCACE;;4BAChB;;wBACI;;+BACD;;AAgBvB,SAASA,WAAT,CACLC,MADK,EAELC,IAFK,EAGLC,SAHK,EAGc;EAEnB;EACA,IAAIC,IAAJ;EACA,IAAIC,cAAc,OAAOH,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkCI,qCAAqBJ,IAArBI,CAApD,CAJmB,CAMnB;EACA;;EACA,MAAMC,gBAAgBF,YAAYG,KAAZH,CAAkB,oBAAlBA,CAAtB;EACA,MAAMI,qBAAqBF,gBACvBF,YAAYK,KAAZL,CAAkBE,aAAa,CAAC,CAAD,CAAbA,CAAiBI,MAAnCN,CADuBE,GAEvBF,WAFJ;EAIA,MAAMO,WAAWH,mBAAmBI,KAAnBJ,CAAyB,GAAzBA,EAA8B,CAA9BA,CAAjB;;EAEA,IAAI,CAACG,QAAQ,CAAC,CAAD,CAARA,IAAe,EAAhB,EAAoBJ,KAApB,CAA0B,WAA1B,CAAJ,EAA4C;IAC1CM,QAAQC,KAARD,CACE,mBAAiBT,WAAjB,GAA6B,oCAA7B,GAAiEJ,OAAOe,QAAxE,GAAiF,+EADnFF;IAGA,MAAMG,gBAAgBC,qCAAyBT,kBAAzBS,CAAtB;IACAb,cAAc,CAACE,gBAAgBA,aAAa,CAAC,CAAD,CAA7BA,GAAmC,EAApC,IAA0CU,aAAxDZ;EACF,CArBmB,CAuBnB;;;EACA,IAAI,CAACc,4BAAWd,WAAXc,CAAL,EAA8B;IAC5B,OAAQhB,YAAY,CAACE,WAAD,CAAZF,GAA4BE,WAApC;EACF;;EAEA,IAAI;IACFD,OAAO,IAAIgB,GAAJ,CACLf,YAAYgB,UAAZhB,CAAuB,GAAvBA,IAA8BJ,OAAOqB,MAArCjB,GAA8CJ,OAAOe,QADhD,EAEL,UAFK,CAAPZ;EAIF,CALA,CAKE,OAAOmB,CAAP,EAAU;IACV;IACAnB,OAAO,IAAIgB,GAAJ,CAAQ,GAAR,EAAa,UAAb,CAAPhB;EACF;;EAEA,IAAI;IACF,MAAMoB,WAAW,IAAIJ,GAAJ,CAAQf,WAAR,EAAqBD,IAArB,CAAjB;IACAoB,SAASR,QAATQ,GAAoBC,wDAA2BD,SAASR,QAApCS,CAApBD;IACA,IAAIE,iBAAiB,EAArB;;IAEA,IACEC,4BAAeH,SAASR,QAAxBW,KACAH,SAASI,YADTD,IAEAxB,SAHF,EAIE;MACA,MAAM0B,QAAQC,yCAAuBN,SAASI,YAAhCE,CAAd;MAEA,MAAM;QAAEC,MAAF;QAAUC;MAAV,IAAqBC,kCACzBT,SAASR,QADgBiB,EAEzBT,SAASR,QAFgBiB,EAGzBJ,KAHyBI,CAA3B;;MAMA,IAAIF,MAAJ,EAAY;QACVL,iBAAiBpB,qCAAqB;UACpCU,UAAUe,MAD0B;UAEpCG,MAAMV,SAASU,IAFqB;UAGpCL,OAAOM,gBAAKN,KAALM,EAAYH,MAAZG;QAH6B,CAArB7B,CAAjBoB;MAKF;IACF,CAzBE,CA2BF;;;IACA,MAAMU,eACJZ,SAASa,MAATb,KAAoBpB,KAAKiC,MAAzBb,GACIA,SAAStB,IAATsB,CAAcd,KAAdc,CAAoBA,SAASa,MAATb,CAAgBb,MAApCa,CADJA,GAEIA,SAAStB,IAHf;IAKA,OAAOC,YACH,CAACiC,YAAD,EAAeV,kBAAkBU,YAAjC,CADGjC,GAEHiC,YAFJ;EAGF,CApCA,CAoCE,OAAOb,CAAP,EAAU;IACV,OAAOpB,YAAY,CAACE,WAAD,CAAZF,GAA4BE,WAAnC;EACF;AACF","names":["resolveHref","router","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","pathname","normalizedUrl","normalizeRepeatedSlashes","isLocalURL","URL","startsWith","asPath","_","finalUrl","normalizePathTrailingSlash","interpolatedAs","isDynamicRoute","searchParams","query","searchParamsToUrlQuery","result","params","interpolateAs","hash","omit","resolvedHref","origin"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\client\\resolve-href.ts"],"sourcesContent":["import type { NextRouter, Url } from '../shared/lib/router/router'\n\nimport { searchParamsToUrlQuery } from '../shared/lib/router/utils/querystring'\nimport { formatWithValidation } from '../shared/lib/router/utils/format-url'\nimport { omit } from '../shared/lib/router/utils/omit'\nimport { normalizeRepeatedSlashes } from '../shared/lib/utils'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\nimport { isLocalURL } from '../shared/lib/router/utils/is-local-url'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport { interpolateAs } from '../shared/lib/router/utils/interpolate-as'\n\n/**\n * Resolves a given hyperlink with a certain router state (basePath not included).\n * Preserves absolute urls.\n */\nexport function resolveHref(\n  router: NextRouter,\n  href: Url,\n  resolveAs: true\n): [string, string] | [string]\nexport function resolveHref(\n  router: NextRouter,\n  href: Url,\n  resolveAs?: false\n): string\nexport function resolveHref(\n  router: NextRouter,\n  href: Url,\n  resolveAs?: boolean\n): [string, string] | [string] | string {\n  // we use a dummy base url for relative urls\n  let base: URL\n  let urlAsString = typeof href === 'string' ? href : formatWithValidation(href)\n\n  // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//)\n  const urlAsStringNoProto = urlProtoMatch\n    ? urlAsString.slice(urlProtoMatch[0].length)\n    : urlAsString\n\n  const urlParts = urlAsStringNoProto.split('?', 1)\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(\n      `Invalid href '${urlAsString}' passed to next/router in page: '${router.pathname}'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.`\n    )\n    const normalizedUrl = normalizeRepeatedSlashes(urlAsStringNoProto)\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl\n  }\n\n  // Return because it cannot be routed by the Next.js router\n  if (!isLocalURL(urlAsString)) {\n    return (resolveAs ? [urlAsString] : urlAsString) as string\n  }\n\n  try {\n    base = new URL(\n      urlAsString.startsWith('#') ? router.asPath : router.pathname,\n      'http://n'\n    )\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n')\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base)\n    finalUrl.pathname = normalizePathTrailingSlash(finalUrl.pathname)\n    let interpolatedAs = ''\n\n    if (\n      isDynamicRoute(finalUrl.pathname) &&\n      finalUrl.searchParams &&\n      resolveAs\n    ) {\n      const query = searchParamsToUrlQuery(finalUrl.searchParams)\n\n      const { result, params } = interpolateAs(\n        finalUrl.pathname,\n        finalUrl.pathname,\n        query\n      )\n\n      if (result) {\n        interpolatedAs = formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omit(query, params),\n        })\n      }\n    }\n\n    // if the origin didn't change, it means we received a relative href\n    const resolvedHref =\n      finalUrl.origin === base.origin\n        ? finalUrl.href.slice(finalUrl.origin.length)\n        : finalUrl.href\n\n    return resolveAs\n      ? [resolvedHref, interpolatedAs || resolvedHref]\n      : resolvedHref\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString\n  }\n}\n"]},"metadata":{},"sourceType":"script"}