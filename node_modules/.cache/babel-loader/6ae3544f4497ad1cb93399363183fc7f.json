{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  hasRemoteMatch: null,\n  matchRemotePattern: null\n});\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  hasRemoteMatch: function () {\n    return hasRemoteMatch;\n  },\n  matchRemotePattern: function () {\n    return matchRemotePattern;\n  }\n});\n\nconst _picomatch = require(\"next/dist/compiled/picomatch\");\n\nfunction matchRemotePattern(pattern, url) {\n  if (pattern.protocol !== undefined) {\n    const actualProto = url.protocol.slice(0, -1);\n\n    if (pattern.protocol !== actualProto) {\n      return false;\n    }\n  }\n\n  if (pattern.port !== undefined) {\n    if (pattern.port !== url.port) {\n      return false;\n    }\n  }\n\n  if (pattern.hostname === undefined) {\n    throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n  } else {\n    if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n      return false;\n    }\n  }\n\n  if (pattern.search !== undefined) {\n    if (pattern.search !== url.search) {\n      return false;\n    }\n  }\n\n  var _pattern_pathname; // Should be the same as writeImagesManifest()\n\n\n  if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n    dot: true\n  }).test(url.pathname)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n  return domains.some(domain => url.hostname === domain) || remotePatterns.some(p => matchRemotePattern(p, url));\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;EAyCgBA,cAAc;WAAdA;;EArCAC,kBAAkB;WAAlBA;;;;2BAHO;;AAGhB,SAASA,kBAAT,CAA4BC,OAA5B,EAAoDC,GAApD,EAA4D;EACjE,IAAID,QAAQE,QAARF,KAAqBG,SAAzB,EAAoC;IAClC,MAAMC,cAAcH,IAAIC,QAAJD,CAAaI,KAAbJ,CAAmB,CAAnBA,EAAsB,CAAC,CAAvBA,CAApB;;IACA,IAAID,QAAQE,QAARF,KAAqBI,WAAzB,EAAsC;MACpC,OAAO,KAAP;IACF;EACF;;EACA,IAAIJ,QAAQM,IAARN,KAAiBG,SAArB,EAAgC;IAC9B,IAAIH,QAAQM,IAARN,KAAiBC,IAAIK,IAAzB,EAA+B;MAC7B,OAAO,KAAP;IACF;EACF;;EAEA,IAAIN,QAAQO,QAARP,KAAqBG,SAAzB,EAAoC;IAClC,MAAM,IAAIK,KAAJ,CACJ,+CAA6CC,KAAKC,SAALD,CAAeT,OAAfS,CADzC,CAAN;EAGF,CAJA,MAIO;IACL,IAAI,CAACE,uBAAOX,QAAQO,QAAfI,EAAyBC,IAAzBD,CAA8BV,IAAIM,QAAlCI,CAAL,EAAkD;MAChD,OAAO,KAAP;IACF;EACF;;EAEA,IAAIX,QAAQa,MAARb,KAAmBG,SAAvB,EAAkC;IAChC,IAAIH,QAAQa,MAARb,KAAmBC,IAAIY,MAA3B,EAAmC;MACjC,OAAO,KAAP;IACF;EACF;;MAGYb,kBA9BqD,CA6BjE;;;EACA,IAAI,CAACW,uBAAOX,6BAAQc,QAARd,KAAgB,IAAhBA,uBAAoB,IAA3BW,EAAiC;IAAEI,KAAK;EAAP,CAAjCJ,EAAgDC,IAAhDD,CAAqDV,IAAIa,QAAzDH,CAAL,EAAyE;IACvE,OAAO,KAAP;EACF;;EAEA,OAAO,IAAP;AACF;;AAEO,SAASb,cAAT,CACLkB,OADK,EAELC,cAFK,EAGLhB,GAHK,EAGG;EAER,OACEe,QAAQE,IAARF,CAAcG,MAAD,IAAYlB,IAAIM,QAAJN,KAAiBkB,MAA1CH,KACAC,eAAeC,IAAfD,CAAqBG,CAAD,IAAOrB,mBAAmBqB,CAAnBrB,EAAsBE,GAAtBF,CAA3BkB,CAFF;AAIF","names":["hasRemoteMatch","matchRemotePattern","pattern","url","protocol","undefined","actualProto","slice","port","hostname","Error","JSON","stringify","makeRe","test","search","pathname","dot","domains","remotePatterns","some","domain","p"],"sources":["C:\\OtpishiAI\\node_modules\\next\\src\\shared\\lib\\match-remote-pattern.ts"],"sourcesContent":["import type { RemotePattern } from './image-config'\nimport { makeRe } from 'next/dist/compiled/picomatch'\n\n// Modifying this function should also modify writeImagesManifest()\nexport function matchRemotePattern(pattern: RemotePattern, url: URL): boolean {\n  if (pattern.protocol !== undefined) {\n    const actualProto = url.protocol.slice(0, -1)\n    if (pattern.protocol !== actualProto) {\n      return false\n    }\n  }\n  if (pattern.port !== undefined) {\n    if (pattern.port !== url.port) {\n      return false\n    }\n  }\n\n  if (pattern.hostname === undefined) {\n    throw new Error(\n      `Pattern should define hostname but found\\n${JSON.stringify(pattern)}`\n    )\n  } else {\n    if (!makeRe(pattern.hostname).test(url.hostname)) {\n      return false\n    }\n  }\n\n  if (pattern.search !== undefined) {\n    if (pattern.search !== url.search) {\n      return false\n    }\n  }\n\n  // Should be the same as writeImagesManifest()\n  if (!makeRe(pattern.pathname ?? '**', { dot: true }).test(url.pathname)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hasRemoteMatch(\n  domains: string[],\n  remotePatterns: RemotePattern[],\n  url: URL\n): boolean {\n  return (\n    domains.some((domain) => url.hostname === domain) ||\n    remotePatterns.some((p) => matchRemotePattern(p, url))\n  )\n}\n"]},"metadata":{},"sourceType":"script"}